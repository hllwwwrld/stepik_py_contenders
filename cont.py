# курс https://stepik.org/course/68343/


# задачка на поиск наибольшего колличества одинаковых символов подряд
coin = input() + 't'
counter = 1
counterMax = []
for i in range(len(coin) - 1):
    if coin[i] == coin[i + 1]:
        counter += 1
    else:
        counterMax.append(counter)
        counter = 1
print(max(counterMax))


# 2.2 шаг 10
# https://stepik.org/lesson/415554/step/10?auth=login&unit=405083
# вывести номера строк, которые содержат комбинация букв a n t o n
n = int(input())

position = []
for i in range(1, n+1):
    counter = 0
    temp = ' '.join(input())
    s = [i for i in temp.split() if i in 'anton']
    for j in 'anton':
        if j in s:
            s = s[s.index(j) + 1:]
            counter += 1
    if counter >= 5:
        position.append(i)

print(*position, sep=' ')


# 2.2 шаг 11
# https://stepik.org/lesson/415554/step/11?auth=login&unit=405083
# поочередно удалять из строки буквы алфавита
s = input()
alph = ['а', 'б', 'в', 'г', 'д', 'е', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я']
s1 = '{0} запретил букву'.format(s)
for i in alph:
    if i in s1:
        print(s1.strip(), i)
        s1 = s1.replace(i, '')
        s1 = s1.replace('  ', ' ')


# bool тип данных
#   False = 0, True = 1
#   оператор and - умножение
#   оператор or - сложение
#   not - отрицание
#   Пример логических выражение:
#   False and True == False, True and True == True, True or False == True, not True == False

# функция bool() приводит типы данных к булевуму по следующей логике:
#   строки: пустая строка — ложь (False), непустая строка — истина (True)
#   числа: нулевое число — ложь (False), ненулевое число (в том числе и меньшее нуля) — истина (True)
#   списки: пустой список — ложь (False), непустой — истина (True)


# Вложенные списки, двойная/тройная индексация
# Работа с вложенными списками принципиально ничем не отличается от работы со списками
# к элементам вложенных списков/самим вложенными спискам можно так - же обращаться по индексам
my_list = ['Python', [10, 20, 30], ['Beegeek', 'Stepik!']]

print(my_list[0][2])       # индексирование строки 'Python', двойная индексация
print(my_list[1][1])       # индексирование списка [10, 20, 30], двойная индексация
print(my_list[2][-1])      # индексирование списка ['Beegeek', 'Stepik!'], двойная индексация
print(my_list[2][-1][-1])  # индексирование строки 'Stepik!', тройная индексация


# при использовании max() на вложенных списках списки сравниваются поэлементно
list1 = [[1, 7], [1, 7, 90], [1, 10]]  # max(list1) == [1, 10]
list2 = [['a', 'b'], ['a', 'b', 'c'], ['c', 'b']]  # max(list2) == [c, b]


# двойная/тройная индексация для обращения к вложенному списку и добавления в него элемента/другого списка
# двойная
list1 = [10, 20, [300, 400, [5000, 6000], 500], 30, 40]
list1[2][2].append(7000)
print(list1)

# тройная
list1 = ['a', 'b', ['c', ['d', 'e', ['f', 'g'], 'k'], 'l'], 'm', 'n']
sub_list = ['h', 'i', 'j']
list1[2][1][2].extend(sub_list)
print(list1)



# 4.2 шаг 12
# https://stepik.org/lesson/416752/step/16?auth=login&unit=406260
# пример задания на работу с вложенными списками
# вывести число: сумму всех чисел списка list1 разделённую на общее количество всех чисел.
list1 = [[1, 7, 8], [9, 7, 102], [102, 106, 105], [100, 99, 98, 103], [1, 2, 3]]
total = 0
counter = 0

for li in list1:
    counter += len(li)
    for i in li:
        total += i
print(total/counter)


# В Python списки – ссылочный тип данных. Конструкция [0] * m возвращает ссылку на список из m нулей.
# Повторение этого элемента n раз создает список из n ссылок на один и тот же список.
# То есть если изменить любой список созданный через подобную конструкцию - изменятся все и остальные
# https://stepik.org/lesson/416753/step/1?auth=login&unit=406261
# 4.3 шаг 1
n, m = int(input()), int(input())

my_list = [[0] * m] * n
my_list[0][0] = 17

print(my_list)


# пример создания вложенного списка с помощью генераторов
n = int(input())
lst = [[i for i in range(1, n + 1)] for i in range(3)]
lst[0][0] = 5
print(lst)



# 4.3 шаг 10
# https://stepik.org/lesson/416753/step/10?auth=login&unit=406261
# Треугольник Паскаля 1
import math
n = int(input())


def pascal(numOfString):
    psclString = [int(math.factorial(numOfString)/(math.factorial(elem)*(math.factorial(numOfString-elem)))) for elem in range(numOfString+1)]
    return psclString


print(pascal(n))



# 4.3 шаг 12
# https://stepik.org/lesson/416753/step/12?auth=login&unit=406261
# упаковка дубликатов, все повторяющиеся символы должны быть записаны как вложенные списки
# основной список - содержит в себе списки с последовательностями одинаковых элементов
def createList(lst):
    lst = lst.split()
    temp = []
    fin = []
    for i in range(len(lst)-1):
        if lst[i] == lst[i+1]:
            temp.append(lst[i+1])
        else:
            temp.append(lst[i])
            fin.append(temp.copy())
            temp.clear()

    for i in lst[-1:]:
        for j in lst[lst.index(i) - 1:]:
            if i == j:
                temp.append(j)
            else:
                temp.append(i)
                fin.append(temp.copy())
                temp.clear()
                break
        break
    if len(temp) != 0:
        fin.append(temp)
    return fin


s = input()


print(createList(s))


# МАТРИЦЫ/методы s.rjust(width, fillchar) и ljust(width, fillchar)
# rjust - выравнивание по правому краю
# width - минимальная длина строки,
# fillchar - символ, которым будет заполняться строка, если len(s) < width

# ljust() - выравнивание по левому краю, парметры как у rjust() параметры
# при выравнивании по левому краю символы строки сдвигаются к левому краю а справа строка заполняется символами fillchar до len(s) == width



# 4.4 шаг 9
# https://stepik.org/lesson/416754/step/9?auth=login&unit=406262
# матрицы, вывести матрицу, потом поменять местами строки со столбцами и вывести
n = int(input())  # кол-во строк
m = int(input())  # кол-во столбцов
matrix = [[input() for i in range(m)] for _ in range(n)]  # создаю матрицу с n строк и m столбцов (вложенный список с n элементов и m элементов внутри самих списков)

# вывожу матрицу
for i in range(len(matrix)):  # запускаю цикл по всем строкам матрицы (элментам верхнего списка)
    print()
    for j in range(len(matrix[i])):  # запускается цикл по всем столбцам (по всем элементам вложенного списка)
        print(matrix[i][j], end=' ')

print()



# инвертирование строк и столбцов
# так - как надо поменять строк и столбцы местами - вывести сначала все первые элементы каждого вложенного списка на одной строке,
# потом все вторые элементы каждого вложенного списка на новой строке и тд
# поэтому при двойной индексации увеличивает первое число - элемент верхнего списка до окончания всех элементов верхнего списка
# потом только начинает увеличиваться второй индекс - номер элемента внутри вложенного цикла (для матриц: увеличивается номер строки до окончания строк, потом номер столбца)
for i in range(len(matrix[0])):  # запускается цикл длиной элемента (длина всех вложенных списков одинаковая)
    print()
    for j in range(len(matrix)):  # запускается цикл по всей матрице
        print(matrix[j][i], end= ' ')  # в двойной индексации увеличиваются сначала элементы верхнего списка до их окончания, потом увеличивается номер выводимого элемента внутри вложенного списка

# в контексте матриц это значит, что мы двигаемся по строкам, выводя сначла первый столбец, пройдя все строки начинается выводить второй столбец и так далее
# и первой строкой новой матрицы будет - первый столбец старой матрицы, так как мы выводим все из первого столбца, потом
# переходим на новую строку и выводим все из второго столбца и так далее



# 4.5 шаг 2
# https://stepik.org/lesson/416755/step/2?auth=login&unit=406263
# Программа должна вывести два числа: номер строки (вложенного списка) и номер столбца (номер элемента вложенного спи ка),
# в которых стоит наибольший элемент таблицы (верхнего списка).

n = int(input())  # кол-во строк
m = int(input())  # кол-во столбцов
matrix = [[int(i) for i in input().split()] for _ in range(n)]  # создаю матрицу (список с глубиной 2)

# записываю в максимум первый элемент первого вложенного списка (первый элемент матрицы)
maximum = max(matrix[0])  # запоминаю максимум из первого вложенного списка (строки матрицы)
ind = 0  # номер элемента внутри верхнего списка (в каком вложенном списке максимум)

for i in range(len(matrix)):  # запускаю цикл по всем вложенным элементам верхнего списка (по всем строкам матрицы)
    if maximum < max(matrix[i]):  # если максимум во вложенном списке (строке матрицы) > чем имеющийся
        maximum = max(matrix[i])  # ставлю максимум найденный элемент
        ind = i  # запоминаю номер вложенного списка, в котором находится элемент (номер строки матрицы)
print(ind, matrix[ind].index(maximum))  # вывожу номер вложенного списка (номер строки матрицы) и первое вхождение этого максимума во вложенный список

matrix[ind].index(maximum)  # конструкция по поиску первого вхождения максимума во вложенном списке (в строке матрицы)



# 4.5 шаг 3
# https://stepik.org/lesson/416755/step/3?auth=login&unit=406263
# Напишите программу, которая меняет местами столбцы в матрице. (поменять во всех вложенных списках пары элементов местами)
n = int(input())
m = int(input())
matrix = [[int(i) for i in input().split()] for _ in range(n)]

i, j = [int(s) for s in input().split()]

for l in range(len(matrix)):
    matrix[l][i], matrix[l][j] = matrix[l][j], matrix[l][i]

for k in matrix:
    print(*k)